typedef enum {
    STATE_HEADER_1,    // First header byte (0xEF)
    STATE_HEADER_2,    // Second header byte (0x01)
    STATE_ADDRESS,     // 4 bytes address
    STATE_PACKET_ID,   // Packet type ID
    STATE_LENGTH_H,    // Length high byte
    STATE_LENGTH_L,    // Length low byte
    STATE_CONTENT,     // Packet content/data
    STATE_CHECKSUM_H,  // Checksum high byte
    STATE_CHECKSUM_L   // Checksum low byte
} ParseState;

typedef struct {
    ParseState state;
    uint8_t address_bytes[4];
    uint16_t content_length;
    uint16_t bytes_read;
    uint8_t addr_index;
    FingerprintPacket *current_packet;
} PacketParser;

MultiPacketResponse* fingerprint_read_response(void) {
    static PacketParser parser = {
        .state = STATE_HEADER_1,
        .bytes_read = 0,
        .addr_index = 0
    };
    
    uint8_t buffer[512];
    MultiPacketResponse *response = NULL;
    size_t packets_allocated = 0;
    const size_t PACKET_ALLOC_INCREMENT = 4;
    
    // Read data with timeout
    int length = uart_read_bytes(UART_NUM, buffer, sizeof(buffer), 500 / portTICK_PERIOD_MS);
    if (length <= 0) return NULL;

    // Allocate initial response structure
    response = heap_caps_malloc(sizeof(MultiPacketResponse), MALLOC_CAP_8BIT);
    if (!response) return NULL;
    
    response->packets = heap_caps_malloc(sizeof(FingerprintPacket*) * PACKET_ALLOC_INCREMENT, MALLOC_CAP_8BIT);
    if (!response->packets) {
        heap_caps_free(response);
        return NULL;
    }
    packets_allocated = PACKET_ALLOC_INCREMENT;
    response->count = 0;

    // Process each byte through the state machine
    for (int i = 0; i < length; i++) {
        uint8_t byte = buffer[i];
        
        switch (parser.state) {
            case STATE_HEADER_1:
                if (byte == 0xEF) {
                    parser.current_packet = heap_caps_malloc(sizeof(FingerprintPacket), MALLOC_CAP_8BIT);
                    if (parser.current_packet) {
                        memset(parser.current_packet, 0, sizeof(FingerprintPacket));
                        parser.current_packet->header = 0xEF00;
                        parser.state = STATE_HEADER_2;
                    }
                }
                break;

            case STATE_HEADER_2:
                if (byte == 0x01) {
                    parser.current_packet->header |= 0x01;
                    parser.addr_index = 0;
                    parser.state = STATE_ADDRESS;
                } else {
                    parser.state = STATE_HEADER_1;
                    heap_caps_free(parser.current_packet);
                }
                break;

            case STATE_ADDRESS:
                parser.address_bytes[parser.addr_index++] = byte;
                if (parser.addr_index == 4) {
                    parser.current_packet->address = 
                        (parser.address_bytes[0] << 24) |
                        (parser.address_bytes[1] << 16) |
                        (parser.address_bytes[2] << 8) |
                        parser.address_bytes[3];
                    parser.state = STATE_PACKET_ID;
                }
                break;

            case STATE_PACKET_ID:
                parser.current_packet->packet_id = byte;
                parser.state = STATE_LENGTH_H;
                break;

            case STATE_LENGTH_H:
                parser.content_length = byte << 8;
                parser.state = STATE_LENGTH_L;
                break;

            case STATE_LENGTH_L:
                parser.content_length |= byte;
                parser.current_packet->length = parser.content_length;
                parser.bytes_read = 0;
                parser.state = STATE_CONTENT;
                break;

            case STATE_CONTENT:
                if (parser.current_packet->packet_id == 0x02 || 
                    parser.current_packet->packet_id == 0x08) {
                    // Template data packet
                    if (parser.bytes_read < sizeof(parser.current_packet->parameters)) {
                        parser.current_packet->parameters[parser.bytes_read] = byte;
                    }
                } else {
                    // Command response packet
                    if (parser.bytes_read == 0) {
                        parser.current_packet->code.confirmation = byte;
                    } else if (parser.bytes_read - 1 < sizeof(parser.current_packet->parameters)) {
                        parser.current_packet->parameters[parser.bytes_read - 1] = byte;
                    }
                }

                parser.bytes_read++;
                if (parser.bytes_read >= parser.content_length) {
                    parser.state = STATE_CHECKSUM_H;
                }
                break;

            case STATE_CHECKSUM_H:
                parser.current_packet->checksum = byte << 8;
                parser.state = STATE_CHECKSUM_L;
                break;

            case STATE_CHECKSUM_L:
                parser.current_packet->checksum |= byte;
                
                // Add packet to response
                if (response->count >= packets_allocated) {
                    FingerprintPacket **new_packets = heap_caps_realloc(
                        response->packets, 
                        sizeof(FingerprintPacket*) * (packets_allocated + PACKET_ALLOC_INCREMENT),
                        MALLOC_CAP_8BIT);
                    
                    if (new_packets) {
                        response->packets = new_packets;
                        packets_allocated += PACKET_ALLOC_INCREMENT;
                    }
                }

                if (response->count < packets_allocated) {
                    response->packets[response->count++] = parser.current_packet;
                }

                parser.state = STATE_HEADER_1;
                break;
        }
    }

    if (response->count == 0) {
        heap_caps_free(response->packets);
        heap_caps_free(response);
        return NULL;
    }

    return response;
}


///////////////////////////////////////////////////////////////////////////////////

void read_response_task(void *pvParameter) {
    while (1) {
        MultiPacketResponse *response = fingerprint_read_response();
        if (response) {
            bool template_complete = false;
            static uint8_t template_buffer[512];
            static size_t template_size = 0;

            for (size_t i = 0; i < response->count; i++) {
                FingerprintPacket *packet = response->packets[i];
                fingerprint_response_t event = {0};
                memcpy(&event.packet, packet, sizeof(FingerprintPacket));

                if (packet->packet_id == 0x02 || packet->packet_id == 0x08) {
                    size_t data_length = packet->length - 2;
                    if (template_size + data_length <= sizeof(template_buffer)) {
                        memcpy(template_buffer + template_size, 
                               packet->parameters, 
                               data_length);
                        template_size += data_length;
                        
                        if (packet->packet_id == 0x08) {
                            template_complete = true;
                        }
                    }
                }

                if (xQueueSend(fingerprint_response_queue, &event, pdMS_TO_TICKS(100)) != pdPASS) {
                    ESP_LOGW(TAG, "Response queue full");
                }

                if (template_complete) {
                    ESP_LOGI(TAG, "Complete template received: %d bytes", template_size);
                    template_size = 0;
                }

                heap_caps_free(packet);
            }
            
            heap_caps_free(response->packets);
            heap_caps_free(response);
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}